// automatically generated by the FlatBuffers compiler, do not modify

package MyGame.Sample

import java.nio.*
import com.google.flatbuffers.*
import kotlin.experimental.and

class Monster : Table() {
    fun __init(_i: Int, _bb: ByteBuffer) {
        bb_pos = _i
        bb = _bb
    }

    fun __assign(_i: Int, _bb: ByteBuffer): Monster {
        __init(_i, _bb)
        return this
    }

    @JvmOverloads
    fun pos(obj: Vec3 = Vec3()): Vec3? {
        val o = __offset(4)
        return if (o != 0) obj.__assign(o + bb_pos, bb) else null
    }

    fun mana(): Short {
        val o = __offset(6)
        return if (o != 0) bb.getShort(o + bb_pos) else 150
    }

    fun mutateMana(mana: Short): Boolean {
        val o = __offset(6)
        if (o != 0) {
            bb.putShort(o + bb_pos, mana)
            return true
        } else {
            return false
        }
    }

    fun hp(): Short {
        val o = __offset(8)
        return if (o != 0) bb.getShort(o + bb_pos) else 100
    }

    fun mutateHp(hp: Short): Boolean {
        val o = __offset(8)
        if (o != 0) {
            bb.putShort(o + bb_pos, hp)
            return true
        } else {
            return false
        }
    }

    fun name(): String? {
        val o = __offset(10)
        return if (o != 0) __string(o + bb_pos) else null
    }

    fun nameAsByteBuffer(): ByteBuffer? {
        return __vector_as_bytebuffer(10, 1)
    }

    fun inventory(j: Int): Int {
        val o = __offset(14)
        return if (o != 0) bb.get(__vector(o) + j * 1) and 0xFF else 0
    }

    fun inventoryLength(): Int {
        val o = __offset(14)
        return if (o != 0) __vector_len(o) else 0
    }

    fun inventoryAsByteBuffer(): ByteBuffer? {
        return __vector_as_bytebuffer(14, 1)
    }

    fun mutateInventory(j: Int, inventory: Int): Boolean {
        val o = __offset(14)
        if (o != 0) {
            bb.put(__vector(o) + j * 1, inventory.toByte())
            return true
        } else {
            return false
        }
    }

    fun color(): Byte {
        val o = __offset(16)
        return if (o != 0) bb.get(o + bb_pos) else 2
    }

    fun mutateColor(color: Byte): Boolean {
        val o = __offset(16)
        if (o != 0) {
            bb.put(o + bb_pos, color)
            return true
        } else {
            return false
        }
    }

    fun weapons(j: Int): Weapon? {
        return weapons(Weapon(), j)
    }

    fun weapons(obj: Weapon, j: Int): Weapon? {
        val o = __offset(18)
        return if (o != 0) obj.__assign(__indirect(__vector(o) + j * 4), bb) else null
    }

    fun weaponsLength(): Int {
        val o = __offset(18)
        return if (o != 0) __vector_len(o) else 0
    }

    fun equippedType(): Byte {
        val o = __offset(20)
        return if (o != 0) bb.get(o + bb_pos) else 0
    }

    fun mutateEquippedType(equipped_type: Byte): Boolean {
        val o = __offset(20)
        if (o != 0) {
            bb.put(o + bb_pos, equipped_type)
            return true
        } else {
            return false
        }
    }

    fun equipped(obj: Table): Table? {
        val o = __offset(22)
        return if (o != 0) __union(obj, o) else null
    }

    companion object {
        @JvmOverloads
        fun getRootAsMonster(_bb: ByteBuffer, obj: Monster = Monster()): Monster {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)
        }

        fun startMonster(builder: FlatBufferBuilder) {
            builder.startObject(10)
        }

        fun addPos(builder: FlatBufferBuilder, posOffset: Int) {
            builder.addStruct(0, posOffset, 0)
        }

        fun addMana(builder: FlatBufferBuilder, mana: Short) {
            builder.addShort(1, mana, 150)
        }

        fun addHp(builder: FlatBufferBuilder, hp: Short) {
            builder.addShort(2, hp, 100)
        }

        fun addName(builder: FlatBufferBuilder, nameOffset: Int) {
            builder.addOffset(3, nameOffset, 0)
        }

        fun addInventory(builder: FlatBufferBuilder, inventoryOffset: Int) {
            builder.addOffset(5, inventoryOffset, 0)
        }

        fun createInventoryVector(builder: FlatBufferBuilder, data: ByteArray): Int {
            builder.startVector(1, data.size, 1)
            for (i in data.indices.reversed()) builder.addByte(data[i])
            return builder.endVector()
        }

        fun startInventoryVector(builder: FlatBufferBuilder, numElems: Int) {
            builder.startVector(1, numElems, 1)
        }

        fun addColor(builder: FlatBufferBuilder, color: Byte) {
            builder.addByte(6, color, 2)
        }

        fun addWeapons(builder: FlatBufferBuilder, weaponsOffset: Int) {
            builder.addOffset(7, weaponsOffset, 0)
        }

        fun createWeaponsVector(builder: FlatBufferBuilder, data: IntArray): Int {
            builder.startVector(4, data.size, 4)
            for (i in data.indices.reversed()) builder.addOffset(data[i])
            return builder.endVector()
        }

        fun startWeaponsVector(builder: FlatBufferBuilder, numElems: Int) {
            builder.startVector(4, numElems, 4)
        }

        fun addEquippedType(builder: FlatBufferBuilder, equippedType: Byte) {
            builder.addByte(8, equippedType, 0)
        }

        fun addEquipped(builder: FlatBufferBuilder, equippedOffset: Int) {
            builder.addOffset(9, equippedOffset, 0)
        }

        fun endMonster(builder: FlatBufferBuilder): Int {
            return builder.endObject()
        }

        fun finishMonsterBuffer(builder: FlatBufferBuilder, offset: Int) {
            builder.finish(offset)
        }
    }
}
